priority 0

snippet ojlibs_ns
namespace ojlibs { // TO_BE_REMOVED
    $1
} // namespace ojlibs TO_BE_REMOVED
endsnippet

snippet fact
// def
static const int FMAX = ?;
int fact[FMAX];
int C(int n, int m) {
    return MUL_MOD(fact[n], INV_MOD(MUL_MOD(fact[m], fact[n - m])));
}
int H(int n, int m) {
    return C(n + m - 1, m);
}
// code
fact[0] = 1;
for (int i : range(1, FMAX))
    fact[i] = MUL_MOD(fact[i - 1], i);
endsnippet

snippet C
// def
static const int CMAX = ?;
int C[CMAX][CMAX];

// init C
C[0][0] = 1;
for (int i : range(1, CMAX)) {
    C[i][0] = C[i][i] = 1;
    for (int j : range(1, i))
        C[i][j] = C[i-1][j-1] + C[i-1][j];
}
endsnippet

snippet psegtree
struct node {
    int cnt;
    node*lc,*rc;
    node();
} pool[N*20],*pm=pool+1,*null=pool,*root[N];
node::node(){lc=rc=null;}

static inline node*modify(node*x,int l,int r,int p) {
    node*v=pm++;*v=*x;
    v->cnt++;
    if(l^r)
    {
        int t=(l+r)>>1;
        if(p<=t)v->lc=modify(x->lc,l,t,p);
        else v->rc=modify(x->rc,t+1,r,p);
    }
    return v;
}

int res;

static inline void query(node*x,node*y,int l,int r,int v) {
    if(x->cnt-y->cnt<v)return;
    if(l==r)repl(res,l);
    int t=(l+r)>>1;
    query(x->lc,y->lc,l,t,v);
    query(x->rc,y->rc,t+1,r,v);
}
endsnippet

snippet lsegtree
#include <ojlibs/lazy_segtree.hpp>
struct linear_op {
    double a, b;
    linear_op(double a = 1, double b = 0) : a(a), b(b) {}
    double operator()(double x, int len) const {
        return a * x + b * len;
    }
    operator bool() {
        return !(a == 1 && b == 0);
    }
    linear_op operator*(const linear_op &that) const {
        // a * (ta * x + tb) + b
        return linear_op(a * that.a, a * that.b + b);
    }
};
lazy_segtree<flt_t, binary_plus<flt_t>, linear_op> seg(TEST_SIZE);
endsnippet

snippet segtree
// definition
static const int OFFSET = 2 << 17;
struct node_t {
    int b, e;
    int64_t sum;
};
node_t seg[2 * OFFSET];
    // rebuild
    for (int i : range(OFFSET)) {
        seg[i + OFFSET].b = i;
        seg[i + OFFSET].e = i + 1;
    }
    for (int i : rev(range(OFFSET))) {
        seg[i].b = seg[i + i].b;
        seg[i].e = seg[i + i + 1].e;
        seg[i].sum = seg[i + i].sum + seg[i + i + 1].sum;
    }
// query
void query_single(int no, int k, int x) {
    node_t &cur = seg[no];
    if (cur.b == k && cur.e == k + 1) {
        return cur.sum;
    }
    int m = (cur.b + cur.e) / 2;
    if (k < m)
        query_single(no + no, k, x);
    else
        query_single(no + no + 1, k, x);

    // recompute
    cur.sum = seg[no + no].sum + seg[no + no + 1].sum;
}
int64_t query_range(int no, int l, int r) {
    node_t &cur = seg[no];
    if (l <= cur.b && r >= cur.e)
        return cur.sum;

    int64_t ans = 0;
    int m = (cur.b + cur.e) / 2;
    if (l < m)
        ans += query_range(no + no, l, r);
    if (r > m)
        ans += query_range(no + no + 1, l, r);
    return ans;
}
endsnippet

snippet dfs_t
void dfs(int u, int prev) {
    for (auto &e : g.edge_list(u)) if (e.to != prev) {
        dfs(e.to, u);
    }
}
endsnippet
snippet dfs_u
bool visit[?MAX];
void dfs(int u) {
    visit[u] = true;
    for (auto &e : g.edge_list(u)) if (!visit[e.to]){
        dfs(e.to);
    }
}
endsnippet

snippet dfs
int visit[?MAX];
void dfs(int u) {
    if (visit[u] == 1)
        ? on loop
        throw 0;
    if (visit[u] == 2)
        ? visited
        return;
    // start time
    visit[u] = 1;
    for (auto &edge : g.edge_list(u)) {
        dfs(e.to);
    }
    // finish time
    visit[u] = 2;
}
endsnippet

snippet tarjan_lca
void tarjan_lca(G &g, Q &q, vector<int> &visit, int u) {
    visit[u] = 1;
    for (auto &e : g.edge_list(u)) {
        if (visit[e.to]) continue;
        ds.union_if(u, e.to);
    }
    visit[u] = 2;
    for (auto &qe : q.edge_list(u)) {
        if (visit[qe.to] == 2) {
            int lca = ds.find(qe.to);
            query_result[qe.id] = lca;
        }
    }
}
endsnippet

snippet dijkstra
void dijkstra(G &g, int u, vector<bool> &visit, vector<int64_t> &dist) {
    typedef pair<int64_t, int> p_t;
    priority_queue<p_t, vector<p_t>, std::greater<p_t>> pq;
    pq.push({0, u});

    while (!pq.empty()) {
        p_t p = pq.top();
        pq.pop();

        if (visit[p.second]) continue;
        visit[p.second] = true;
        dist[p.second] = p.first;
        for (auto &e : g.edge_list(p.second)) {
            if (!visit[e.to]) pq.push({p.first + e.info.length, e.to});
        }
    }
}
endsnippet

snippet lca
int depth[100005];
int parent[100005][20]; // parent[x][j] is 2^j parent of x

// compute parent
for (int j : range(1, 20)) {
    for (int u : nrange(n)) {
        parent[u][j] = parent[parent[u][j-1]][j-1];
    }
}

int nth_parent(int u, int p) {
    int j = 0;
    while (p) {
        if (p & 1) u = parent[u][j];
        ++j;
        p >>= 1;
    }
    return u;
}
int lca(int u, int v) {
    if (depth[u] < depth[v])
        swap(u, v);

    u = nth_parent(u, depth[u] - depth[v]);
    if (u == v) return u;

    for (int p = 19; p >= 0; --p)
        if (parent[u][p] != parent[v][p])
            u = parent[u][p], v = parent[v][p];
    return parent[u][0];
}
int tree_distance(int u, int v) {
    int ans = 0;
    if (depth[u] < depth[v])
        swap(u, v);

    ans += depth[u] - depth[v];
    u = nth_parent(u, depth[u] - depth[v]);
    if (u == v) return ans;

    for (int p = 19; p >= 0; --p)
        if (parent[u][p] != parent[v][p])
            u = parent[u][p], v = parent[v][p], ans += (2 << p);
    return ans + 2;
}
endsnippet

snippet mat
#define MAT_ZERO 0
#define MAT_ONE  1
#define MAT_ADD  ADDX_MOD
#define MAT_MUL  MUL_MOD
typedef vector<vector<int>> mat_t;
mat_t make_mat(int m, int n) { return mat_t(m, vector<int>(n, MAT_ZERO)); }
mat_t make_eye(int n) {
    mat_t ret = make_mat(n, n);
    for (int i = 0; i < n; ++i)
        ret[i][i] = MAT_ONE;
    return ret;
}
mat_t operator *(const mat_t &m1, const mat_t &m2) {
    int m = (int)m1.size();
    int n = (int)m1[0].size();
    int p = (int)m2[0].size();
    assert(n == m2.size());

    mat_t ret = make_mat(m, p);
    for (int i = 0; i < m; ++i)
        for (int k = 0; k < p; ++k) {
            int ans = MAT_ZERO;
            for (int j = 0; j < n; ++j)
                ans = MAT_ADD(ans, MAT_MUL(m1[i][j], m2[j][k]));
            ret[i][k] = ans;
        }
    return ret;
}
endsnippet

snippet mod7
static const int MOD = 1000000007;
endsnippet
snippet mod9
static const int MOD = 1000000009;
endsnippet
snippet maxn
static const int maxn$1 = 100005;
endsnippet

snippet dir4
const int dir[4][2] = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };
endsnippet

snippet bsearch
int? low = ?, high = ?;
while (high - low > 1) {
    int? mid = (low + high) / 2;
    if (?) low = mid;
    else high = mid;
}
endsnippet

snippet fbsearch
double low = ?, high = ?;
for (int _ = 0; _ < 150; ++_) {
    double mid = (low + high) / 2;
    if (?) low = mid;
    else high = mid;
}
endsnippet

snippet review
// REVIEW:
// --------------------
// DO IT AGAIN ?? (0-3)
// RECOMMEND: ?? (1-5)
// DIFFICULTY (1-5)
//   IMPL:
//   IDEA:
endsnippet
